from fastapi import FastAPI, File, UploadFile
from pydantic import BaseModel
from typing import Optional, List, Dict, Any, Tuple 
from datetime import datetime
import os
from fastapi.responses import StreamingResponse, FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from app.llm_service import llm_service
import httpx
import logging
import traceback
import asyncio
import tempfile
import shutil
import subprocess
from app.config import ConfigManager
from app.db.factory import DatabaseFactory
from app.schema_loader import load_schema
import time

# Import both regex-based and the conceptual LLM-based functions
from app.nl_to_sql import generate_sql_via_llm

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Serve static files for the frontend
app.mount("/static", StaticFiles(directory="public"), name="static")

# Global config manager
config_manager = ConfigManager()
DEFAULT_DB_NAME = config_manager.get_active_database()

def get_db_adapter(db_name: str = 'default'):
    db_config = config_manager.get_database_config(db_name)
    if not db_config:
        raise ValueError(f"No database config found for '{db_name}'")
    db = DatabaseFactory.create_database(db_config)
    db.connect()
    return db

class ChatMessage(BaseModel):
    role: str # "user" or "assistant"
    content: str

class QueryRequest(BaseModel):
    question: str
    chat_history: Optional[List[ChatMessage]] = None
    # start_timestamp and end_timestamp are not directly used here anymore
    # as they should be part of the natural language question if needed.

class QueryResponse(BaseModel):
    answer: Optional[str] = None
    query: Optional[str] = None
    results: Optional[List[Dict[str, Any]]] = None
    error: Optional[str] = None
    debug_info: Optional[str] = None # For LLM prompts or other info

def format_results_for_display(results: List[Tuple], column_names: List[str]) -> str:
    """Formats SQL results into a human-readable string."""
    if not results:
        return "No data found for your query."

    # If a single value is returned (e.g., SUM, COUNT)
    if len(results) == 1 and len(results[0]) == 1:
        return str(results[0][0])

    # For multiple rows/columns, create a simple table string
    header = " | ".join(column_names)
    rows_str = [" | ".join(map(str, row)) for row in results]
    return "\n".join([header] + rows_str)

@app.get("/")
async def read_index():
    return FileResponse('public/index.html')

@app.get("/speech-test")
async def speech_test_page():
    """Serve the speech recognition test page"""
    return FileResponse('public/speech_test.html')

@app.post('/ask', response_model=QueryResponse)
async def ask_question(req: QueryRequest, db_name: str = DEFAULT_DB_NAME):
    sql_query = None
    debug_message = ""
    db = None
    timings = {}
    total_start = time.time()

    debug_message = ""
    chat_history_dicts = [msg.dict() for msg in req.chat_history] if req.chat_history else None
    # Dynamically load schema for the selected db_name
    try:
        schema = load_schema(db_name=db_name)
    except Exception as e:
        debug_message = f"Schema load error: {e}"
        return QueryResponse(error=f"Schema load error: {e}", debug_info=debug_message)
    llm_start = time.time()
    sql_query_llm = generate_sql_via_llm(req.question, chat_history_dicts, db_schema=schema, db_name=db_name)
    timings['llm'] = time.time() - llm_start
    if sql_query_llm:
        if "<dynamic_start_time>" in sql_query_llm:
            debug_message += " LLM produced a template. Dynamic timestamp replacement is conceptual."
            return QueryResponse(error="LLM generated a query template that requires dynamic data not yet implemented.", query=sql_query_llm, debug_info=debug_message)
        sql_query = sql_query_llm
        debug_message += f" Query generated by LLM: {sql_query}"
    else:
        debug_message += " LLM also failed to generate a query."

    if not sql_query:
        return QueryResponse(error="Sorry, I couldn't understand your question or convert it to a database query.", debug_info=debug_message)

    try:
        db = get_db_adapter(db_name)
        mysql_start = time.time()
        results, column_names = db.execute_query(sql_query)
        timings['mysql'] = time.time() - mysql_start
        formatted_answer = format_results_for_display(results, column_names)
        results_as_dict = [dict(zip(column_names, row)) for row in results]
        timings['total'] = time.time() - total_start
        logger.info(f"[TIMING] LLM: {timings['llm']:.2f}s, MySQL: {timings['mysql']:.2f}s, Total: {timings['total']:.2f}s for question: {req.question}")
        return QueryResponse(answer=formatted_answer, query=sql_query, results=results_as_dict, debug_info=debug_message)
    except Exception as e:
        timings['total'] = time.time() - total_start
        logger.error(f"[TIMING] LLM: {timings.get('llm', 0):.2f}s, MySQL: {timings.get('mysql', 0):.2f}s, Total: {timings['total']:.2f}s for question: {req.question}")
        return QueryResponse(error=f"Database error: {e}", query=sql_query, debug_info=debug_message)
    finally:
        if db:
            db.disconnect()

@app.post('/ask/stream') 
async def ask_question_stream(req: QueryRequest, db_name: str = DEFAULT_DB_NAME):
    """Streaming version of the ask endpoint."""
    async def generate_stream():
        db = None
        try:
            chat_history_dicts = [msg.dict() for msg in req.chat_history] if req.chat_history else None
            # Dynamically load schema for the selected db_name
            try:
                schema = load_schema(db_name=db_name)
            except Exception as e:
                yield f"Schema load error: {e}\n"
                return
            sql_query = generate_sql_via_llm(req.question, chat_history_dicts, db_schema=schema, db_name=db_name)
            if not sql_query:
                yield "Error: Could not generate SQL query.\n"
                return
            db = get_db_adapter(db_name)
            results, column_names = db.execute_query(sql_query)
            yield "SQL Query:\n"
            yield f"{sql_query}\n\n"
            yield "Results:\n"
            if column_names:
                yield " | ".join(column_names) + "\n"
                yield "-" * (sum(len(col) + 3 for col in column_names) -1) + "\n" 
            for row in results:
                yield " | ".join(str(cell) for cell in row) + "\n"
        except Exception as e:
            yield f"Error: {str(e)}\n"
        finally:
            if db:
                db.disconnect()
    return StreamingResponse(generate_stream(), media_type="text/plain")

@app.post("/recognize")
async def proxy_recognize(file: UploadFile = File(...)):
    """
    Proxy endpoint for speech recognition to avoid CORS issues.
    This forwards the request to the local API at port 8001.
    """
    logger.info(f"Received speech recognition request - file: {file.filename}, content_type: {file.content_type}, size: {file.size if hasattr(file, 'size') else 'unknown'}")
    
    # First, check if the speech recognition server is actually running
    try:
        async with httpx.AsyncClient(timeout=2.0) as client:
            try:
                health_check = await client.get("http://localhost:8001/health", timeout=2.0)
                logger.info(f"Speech recognition server health check: {health_check.status_code}")
            except Exception as health_err:
                logger.warning(f"Speech recognition server health check failed: {str(health_err)}")
                logger.warning("Proceeding anyway, as the /health endpoint might not exist")
    except Exception as e:
        logger.error(f"Error during health check: {str(e)}")
        # Continue anyway, as this is just a diagnostic check
    
    try:
        # Read the uploaded file content
        content = await file.read()
        logger.info(f"Successfully read file content, size: {len(content)} bytes")
        
        # Check the audio format and log details
        # Browser recording typically gives webm, but local API might expect wav
        if file.content_type:
            logger.info(f"File content type: {file.content_type}")
            
            # For debugging purposes, log first few bytes of the file
            if len(content) > 20:
                logger.info(f"File header bytes: {content[:20].hex()}")
        
        # Create a client to forward the request
        logger.info("Forwarding request to speech recognition API at http://localhost:8001/recognize")
        async with httpx.AsyncClient(timeout=30.0) as client:  # Increased timeout
            try:
                # Forward the file to the speech recognition API with proper headers
                files = {'file': (file.filename, content, file.content_type)}
                
                # Include the headers that the working curl command uses
                headers = {
                    'accept': 'application/json',
                    # Content-Type is set automatically when using files parameter
                }
                
                logger.info(f"Sending request with file type: {file.content_type}, headers: {headers}")
                response = await client.post(
                    "http://localhost:8001/recognize", 
                    files=files,
                    headers=headers
                )
                logger.info(f"Speech API response status: {response.status_code}")
                
                # Try to parse the JSON response
                try:
                    logger.info(f"Speech API response content: {response}")
                    response_json = response.json()
                    logger.info(f"Speech API response content: {response_json}")
                    
                    # Return the response from the speech recognition API
                    return JSONResponse(
                        content=response_json,
                        status_code=response.status_code
                    )
                except Exception as json_err:
                    logger.error(f"Failed to parse JSON response: {str(json_err)}")
                    logger.error(f"Response text: {response.text}")
                    return JSONResponse(
                        content={"error": f"Speech API returned invalid JSON: {str(json_err)}", "raw_response": response.text},
                        status_code=500
                    )
            except httpx.ConnectError as conn_err:
                logger.error(f"Failed to connect to speech recognition API: {str(conn_err)}")
                return JSONResponse(
                    content={"error": f"Could not connect to speech recognition API at http://localhost:8001/recognize. Is it running?"},
                    status_code=503  # Service Unavailable
                )
            except httpx.TimeoutException as timeout_err:
                logger.error(f"Request to speech recognition API timed out: {str(timeout_err)}")
                return JSONResponse(
                    content={"error": "Speech recognition request timed out"},
                    status_code=504  # Gateway Timeout
                )
            except Exception as req_err:
                logger.error(f"Error making request to speech recognition API: {str(req_err)}")
                logger.error(traceback.format_exc())
                return JSONResponse(
                    content={"error": f"Error forwarding request: {str(req_err)}"},
                    status_code=500
                )
    except Exception as e:
        logger.error(f"General error in proxy_recognize: {str(e)}")
        logger.error(traceback.format_exc())
        return JSONResponse(
            content={"error": f"Speech recognition proxy failed: {str(e)}"},
            status_code=500
        )

@app.get("/recognize/test")
async def test_recognize_proxy():
    """
    Simple test endpoint to verify the speech recognition proxy functionality.
    """
    try:
        # Test if we can connect to the speech recognition server
        async with httpx.AsyncClient(timeout=5.0) as client:
            try:
                response = await client.get("http://localhost:8001/")
                return {
                    "status": "success",
                    "message": "Successfully connected to speech recognition API",
                    "target_status": response.status_code,
                    "target_response": response.text[:100] + "..." if len(response.text) > 100 else response.text
                }
            except httpx.ConnectError:
                return {
                    "status": "error",
                    "message": "Could not connect to speech recognition API at http://localhost:8001/. Is it running?",
                    "error_type": "ConnectionError"
                }
            except Exception as e:
                return {
                    "status": "error",
                    "message": f"Error connecting to speech recognition API: {str(e)}",
                    "error_type": type(e).__name__
                }
    except Exception as e:
        return {
            "status": "error",
            "message": f"General error testing speech recognition proxy: {str(e)}",
            "error_type": type(e).__name__
        }

@app.post("/recognize/curl-test")
async def test_recognize_with_curl(file: UploadFile = File(...)):
    """
    Test endpoint that uses curl to call the speech recognition API using the same parameters 
    as the known working curl command.
    """
    try:
        # Check if curl is available
        try:
            subprocess.run(["curl", "--version"], check=True, capture_output=True)
        except (subprocess.SubprocessError, FileNotFoundError):
            return JSONResponse(
                content={"error": "curl is not available on this system"},
                status_code=500
            )
        
        # Save the uploaded file to a temporary location
        temp_dir = tempfile.mkdtemp()
        try:
            temp_file_path = os.path.join(temp_dir, file.filename)
            with open(temp_file_path, "wb") as temp_file:
                content = await file.read()
                temp_file.write(content)
            
            logger.info(f"Saved uploaded file to {temp_file_path}")
            
            # Run curl command similar to the known working one
            cmd = [
                "curl", "-X", "POST",
                "http://localhost:8001/recognize",
                "-H", "accept: application/json",
                "-H", "Content-Type: multipart/form-data",
                "-F", f"file=@{temp_file_path};type={file.content_type or 'video/quicktime'}"
            ]
            
            logger.info(f"Running curl command: {' '.join(cmd)}")
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            logger.info(f"Curl exit code: {result.returncode}")
            logger.info(f"Curl stdout: {result.stdout}")
            logger.info(f"Curl stderr: {result.stderr}")
            
            if result.returncode != 0:
                return JSONResponse(
                    content={
                        "error": f"Curl command failed with exit code {result.returncode}",
                        "stderr": result.stderr,
                        "stdout": result.stdout,
                        "command": " ".join(cmd)
                    },
                    status_code=500
                )
            
            try:
                # Try to parse the response as JSON
                import json
                json_response = json.loads(result.stdout)
                return JSONResponse(content=json_response)
            except json.JSONDecodeError:
                # Return the raw response if it's not valid JSON
                return JSONResponse(
                    content={
                        "raw_response": result.stdout,
                        "error": "Response is not valid JSON"
                    },
                    status_code=500
                )
        finally:
            # Clean up the temporary directory
            shutil.rmtree(temp_dir, ignore_errors=True)
            
    except Exception as e:
        logger.error(f"Error in curl test: {str(e)}")
        logger.error(traceback.format_exc())
        return JSONResponse(
            content={"error": f"Error testing with curl: {str(e)}"},
            status_code=500
        )

# To run: uvicorn app.chat_service:app --reload 