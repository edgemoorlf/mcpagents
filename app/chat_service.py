from fastapi import FastAPI, File, UploadFile
from pydantic import BaseModel
from typing import Optional, List, Dict, Any, Tuple 
from datetime import datetime
import sqlite3
import os
from fastapi.responses import StreamingResponse, FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from app.llm_service import llm_service
import httpx
import logging
import traceback
import asyncio
import tempfile
import shutil
import subprocess

# Import both regex-based and the conceptual LLM-based functions
from app.nl_to_sql import generate_sql_from_question_regex, generate_sql_via_llm, TABLE_SCHEMA

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Serve static files for the frontend
app.mount("/static", StaticFiles(directory="public"), name="static")


# Determine the correct path to the database file relative to chatbox.py
# Assuming chatbox.py is in app/ and model_stats.db is in data/
# The path from app/ to data/ is ../data/
DB_FILE = os.path.join(os.path.dirname(__file__), '..', 'data', 'model_stats.db')

class ChatMessage(BaseModel):
    role: str # "user" or "assistant"
    content: str

class QueryRequest(BaseModel):
    question: str
    chat_history: Optional[List[ChatMessage]] = None
    # start_timestamp and end_timestamp are not directly used here anymore
    # as they should be part of the natural language question if needed.

class QueryResponse(BaseModel):
    answer: Optional[str] = None
    query: Optional[str] = None
    results: Optional[List[Dict[str, Any]]] = None
    error: Optional[str] = None
    debug_info: Optional[str] = None # For LLM prompts or other info

def format_results_for_display(results: List[Tuple], column_names: List[str]) -> str:
    """Formats SQL results into a human-readable string."""
    if not results:
        return "No data found for your query."

    # If a single value is returned (e.g., SUM, COUNT)
    if len(results) == 1 and len(results[0]) == 1:
        return str(results[0][0])

    # For multiple rows/columns, create a simple table string
    header = " | ".join(column_names)
    rows_str = [" | ".join(map(str, row)) for row in results]
    return "\n".join([header] + rows_str)

@app.get("/")
async def read_index():
    return FileResponse('public/index.html')

@app.get("/speech-test")
async def speech_test_page():
    """Serve the speech recognition test page"""
    return FileResponse('public/speech_test.html')

@app.post('/ask', response_model=QueryResponse)
async def ask_question(req: QueryRequest): 
    sql_query = None
    debug_message = ""

    # 1. Try rule-based (regex) approach first
    if not req.chat_history: # Regex approach doesn't use history
        sql_query = generate_sql_from_question_regex(req.question)
        if sql_query:
            debug_message = "Query generated by rule-based (regex) system."

    # 2. If regex fails or if chat history is present (suggesting context might be needed for LLM)
    #    Fall back to LLM-based approach.
    if not sql_query:
        debug_message = "Rule-based query failed or history present; trying LLM approach."
        # Convert chat_history to list of dicts if present
        chat_history_dicts = [msg.dict() for msg in req.chat_history] if req.chat_history else None
        sql_query_llm = generate_sql_via_llm(req.question, chat_history_dicts, TABLE_SCHEMA)
        
        if sql_query_llm:
            if "<dynamic_start_time>" in sql_query_llm:
                debug_message += " LLM produced a template. Dynamic timestamp replacement is conceptual."
                return QueryResponse(error="LLM generated a query template that requires dynamic data not yet implemented.", query=sql_query_llm, debug_info=debug_message)
            sql_query = sql_query_llm
            debug_message += f" Query generated by LLM: {sql_query}"
        else:
            debug_message += " LLM also failed to generate a query."

    if not sql_query:
        return QueryResponse(error="Sorry, I couldn't understand your question or convert it to a database query.", debug_info=debug_message)

    try:
        actual_db_path = os.path.abspath(DB_FILE)
        if not os.path.exists(actual_db_path):
             return QueryResponse(error=f"Database file not found at {actual_db_path}. Please run the import script first.", query=sql_query, debug_info=debug_message)
        
        conn = sqlite3.connect(actual_db_path)
        cursor = conn.cursor()
        cursor.execute(sql_query)
        query_results = cursor.fetchall()
        column_names = [desc[0] for desc in cursor.description] if cursor.description else []
        conn.close()

        formatted_answer = format_results_for_display(query_results, column_names)
        
        results_as_dict = [dict(zip(column_names, row)) for row in query_results]

        return QueryResponse(answer=formatted_answer, query=sql_query, results=results_as_dict, debug_info=debug_message)

    except sqlite3.Error as e:
        return QueryResponse(error=f"Database error: {e}", query=sql_query, debug_info=debug_message)
    except Exception as e:
        return QueryResponse(error=f"An unexpected error occurred: {e}", query=sql_query, debug_info=debug_message)

@app.post('/ask/stream') 
async def ask_question_stream(req: QueryRequest): 
    """Streaming version of the ask endpoint."""
    async def generate_stream():
        try:
            chat_history_dicts = [msg.dict() for msg in req.chat_history] if req.chat_history else None
            sql_query = generate_sql_from_question_regex(req.question)
            if not sql_query:
                sql_query = generate_sql_via_llm(req.question, chat_history_dicts, TABLE_SCHEMA)
            
            if not sql_query:
                yield "Error: Could not generate SQL query.\n"
                return

            actual_db_path = os.path.abspath(DB_FILE)
            if not os.path.exists(actual_db_path):
                yield f"Error: Database file not found at {actual_db_path}\n"
                return

            conn = sqlite3.connect(actual_db_path)
            cursor = conn.cursor()
            cursor.execute(sql_query)
            query_results = cursor.fetchall()
            column_names = [desc[0] for desc in cursor.description] if cursor.description else []
            conn.close()

            yield "SQL Query:\n"
            yield f"{sql_query}\n\n"
            yield "Results:\n"
            
            if column_names:
                yield " | ".join(column_names) + "\n"
                yield "-" * (sum(len(col) + 3 for col in column_names) -1) + "\n" 
            
            for row in query_results:
                yield " | ".join(str(cell) for cell in row) + "\n"

        except Exception as e:
            yield f"Error: {str(e)}\n"

    return StreamingResponse(generate_stream(), media_type="text/plain")

@app.post("/recognize")
async def proxy_recognize(file: UploadFile = File(...)):
    """
    Proxy endpoint for speech recognition to avoid CORS issues.
    This forwards the request to the local API at port 8001.
    """
    logger.info(f"Received speech recognition request - file: {file.filename}, content_type: {file.content_type}, size: {file.size if hasattr(file, 'size') else 'unknown'}")
    
    # First, check if the speech recognition server is actually running
    try:
        async with httpx.AsyncClient(timeout=2.0) as client:
            try:
                health_check = await client.get("http://localhost:8001/health", timeout=2.0)
                logger.info(f"Speech recognition server health check: {health_check.status_code}")
            except Exception as health_err:
                logger.warning(f"Speech recognition server health check failed: {str(health_err)}")
                logger.warning("Proceeding anyway, as the /health endpoint might not exist")
    except Exception as e:
        logger.error(f"Error during health check: {str(e)}")
        # Continue anyway, as this is just a diagnostic check
    
    try:
        # Read the uploaded file content
        content = await file.read()
        logger.info(f"Successfully read file content, size: {len(content)} bytes")
        
        # Check the audio format and log details
        # Browser recording typically gives webm, but local API might expect wav
        if file.content_type:
            logger.info(f"File content type: {file.content_type}")
            
            # For debugging purposes, log first few bytes of the file
            if len(content) > 20:
                logger.info(f"File header bytes: {content[:20].hex()}")
        
        # Create a client to forward the request
        logger.info("Forwarding request to speech recognition API at http://localhost:8001/recognize")
        async with httpx.AsyncClient(timeout=30.0) as client:  # Increased timeout
            try:
                # Forward the file to the speech recognition API with proper headers
                files = {'file': (file.filename, content, file.content_type)}
                
                # Include the headers that the working curl command uses
                headers = {
                    'accept': 'application/json',
                    # Content-Type is set automatically when using files parameter
                }
                
                logger.info(f"Sending request with file type: {file.content_type}, headers: {headers}")
                response = await client.post(
                    "http://localhost:8001/recognize", 
                    files=files,
                    headers=headers
                )
                logger.info(f"Speech API response status: {response.status_code}")
                
                # Try to parse the JSON response
                try:
                    logger.info(f"Speech API response content: {response}")
                    response_json = response.json()
                    logger.info(f"Speech API response content: {response_json}")
                    
                    # Return the response from the speech recognition API
                    return JSONResponse(
                        content=response_json,
                        status_code=response.status_code
                    )
                except Exception as json_err:
                    logger.error(f"Failed to parse JSON response: {str(json_err)}")
                    logger.error(f"Response text: {response.text}")
                    return JSONResponse(
                        content={"error": f"Speech API returned invalid JSON: {str(json_err)}", "raw_response": response.text},
                        status_code=500
                    )
            except httpx.ConnectError as conn_err:
                logger.error(f"Failed to connect to speech recognition API: {str(conn_err)}")
                return JSONResponse(
                    content={"error": f"Could not connect to speech recognition API at http://localhost:8001/recognize. Is it running?"},
                    status_code=503  # Service Unavailable
                )
            except httpx.TimeoutException as timeout_err:
                logger.error(f"Request to speech recognition API timed out: {str(timeout_err)}")
                return JSONResponse(
                    content={"error": "Speech recognition request timed out"},
                    status_code=504  # Gateway Timeout
                )
            except Exception as req_err:
                logger.error(f"Error making request to speech recognition API: {str(req_err)}")
                logger.error(traceback.format_exc())
                return JSONResponse(
                    content={"error": f"Error forwarding request: {str(req_err)}"},
                    status_code=500
                )
    except Exception as e:
        logger.error(f"General error in proxy_recognize: {str(e)}")
        logger.error(traceback.format_exc())
        return JSONResponse(
            content={"error": f"Speech recognition proxy failed: {str(e)}"},
            status_code=500
        )

@app.get("/recognize/test")
async def test_recognize_proxy():
    """
    Simple test endpoint to verify the speech recognition proxy functionality.
    """
    try:
        # Test if we can connect to the speech recognition server
        async with httpx.AsyncClient(timeout=5.0) as client:
            try:
                response = await client.get("http://localhost:8001/")
                return {
                    "status": "success",
                    "message": "Successfully connected to speech recognition API",
                    "target_status": response.status_code,
                    "target_response": response.text[:100] + "..." if len(response.text) > 100 else response.text
                }
            except httpx.ConnectError:
                return {
                    "status": "error",
                    "message": "Could not connect to speech recognition API at http://localhost:8001/. Is it running?",
                    "error_type": "ConnectionError"
                }
            except Exception as e:
                return {
                    "status": "error",
                    "message": f"Error connecting to speech recognition API: {str(e)}",
                    "error_type": type(e).__name__
                }
    except Exception as e:
        return {
            "status": "error",
            "message": f"General error testing speech recognition proxy: {str(e)}",
            "error_type": type(e).__name__
        }

@app.post("/recognize/curl-test")
async def test_recognize_with_curl(file: UploadFile = File(...)):
    """
    Test endpoint that uses curl to call the speech recognition API using the same parameters 
    as the known working curl command.
    """
    try:
        # Check if curl is available
        try:
            subprocess.run(["curl", "--version"], check=True, capture_output=True)
        except (subprocess.SubprocessError, FileNotFoundError):
            return JSONResponse(
                content={"error": "curl is not available on this system"},
                status_code=500
            )
        
        # Save the uploaded file to a temporary location
        temp_dir = tempfile.mkdtemp()
        try:
            temp_file_path = os.path.join(temp_dir, file.filename)
            with open(temp_file_path, "wb") as temp_file:
                content = await file.read()
                temp_file.write(content)
            
            logger.info(f"Saved uploaded file to {temp_file_path}")
            
            # Run curl command similar to the known working one
            cmd = [
                "curl", "-X", "POST",
                "http://localhost:8001/recognize",
                "-H", "accept: application/json",
                "-H", "Content-Type: multipart/form-data",
                "-F", f"file=@{temp_file_path};type={file.content_type or 'video/quicktime'}"
            ]
            
            logger.info(f"Running curl command: {' '.join(cmd)}")
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            logger.info(f"Curl exit code: {result.returncode}")
            logger.info(f"Curl stdout: {result.stdout}")
            logger.info(f"Curl stderr: {result.stderr}")
            
            if result.returncode != 0:
                return JSONResponse(
                    content={
                        "error": f"Curl command failed with exit code {result.returncode}",
                        "stderr": result.stderr,
                        "stdout": result.stdout,
                        "command": " ".join(cmd)
                    },
                    status_code=500
                )
            
            try:
                # Try to parse the response as JSON
                import json
                json_response = json.loads(result.stdout)
                return JSONResponse(content=json_response)
            except json.JSONDecodeError:
                # Return the raw response if it's not valid JSON
                return JSONResponse(
                    content={
                        "raw_response": result.stdout,
                        "error": "Response is not valid JSON"
                    },
                    status_code=500
                )
        finally:
            # Clean up the temporary directory
            shutil.rmtree(temp_dir, ignore_errors=True)
            
    except Exception as e:
        logger.error(f"Error in curl test: {str(e)}")
        logger.error(traceback.format_exc())
        return JSONResponse(
            content={"error": f"Error testing with curl: {str(e)}"},
            status_code=500
        )

# To run: uvicorn app.chat_service:app --reload 